## `this`

> 대부분의 경우 `this`의 값은 함수를 호출한 방법에 의해 결정된다.

- `this`는 호출한 놈이다.
- 호출한 놈이 없을 경우에는 기본값으로 `window` 객체이다.
- **예외**
  - 전역 스코프에서 `this`는 `window` 객체이다.
  - 화살표 함수(Arrow Function)에서 `this`가 조금 달라진다.
  - Strict Mode에서는 `this`가 조금 달라진다.

이렇게 `print 메서드` 호출 시 `undefined`가 출력되는 이유는 호출한 놈이 다르기 때문이다.

<br />

### 전역 스코프에서의 `this`

```javascript
// 웹 브라우저에서 window 객체가 전역 객체임
console.log(this); // window
consloe.log(this === window); // true
```

<br />

### Arrow Function `this` (ES6)

화살표 함수(Arrow Function)가 나오기 전까지는 함수는 어떻게 호출되는지에 따라 자신의 `this` 값을 정의했다.
하지만 화살표 함수는 자신을 포함하고 있는 외부 Scope에서 `this`를 계승받는다.
화살표 함수에서 `this`는 자신을 감싼 정적 범위이다.

```javascript
let person = {
  name: "띠닝",
  printThis: () => {
    console.log(this); // window 객체
  },
};
```

```javascript
let person = {
  name: "띠닝",
  printThis: function () {
    setTimeout(() => {
      console.log(this); // person 객체
    }, 3000);
  },
};
```

<br />

### Strict Mode `this`

엄격 모드(Strict Mode)에서는 호출한 놈이 없을 경우 기본값을 `window`로 하지 않고 `undefined`로 한다. (더욱 엄격하게 검사)

- non strict mode

  ```javascript
  function printThis() {
    console.log(this);
  }

  printThis(); // window 객체
  ```

- strict mode

  ```javascript
  "use strict";

  function printThis() {
    console.log(this);
  }

  printThis(); // undefined
  ```

<br />

### 화살표 함수를 사용하면 안 되는 경우

- 객체 메서드를 선언할 때 사용하면 안된다.
  ```javascript
  let person = {
    name: "띠닝",
    printThis: () => {
      console.log(this); // window 객체
    },
  };
  ```
- `addEventListener` 함수의 콜백 함수에서 사용하면 `this`가 상위 컨텍스트를 가리킨다.
  - 화살표 함수로 등록하면 `this` → `window` 객체
    ```javascript
    let btn = document.querySelector("button");
    button.addEventListener("click", () => {
      console.log(this === window); // true
      this.innerHTML = "Clicked button";
    });
    ```
  - 일반 함수로 등록하면 `this` → `button` 요소
    ```javascript
    let btn = document.querySelector("button");
    button.addEventListener("click", function () {
      console.log(this === button); // true
      this.innerHTML = "Clicked button";
    });
    ```
