# 🍰 한입 크기로 잘라 먹는 리액트

## 섹션 10. 최적화

<br>

### 🌱 목차

- [x] 최적화란
- [x] `useMemo`와 연산 최적화
- [x] `React.memo`와 컴포넌트 렌더링 최적화
- [x] `useCallback`과 함수 재생성 방지

<br>
<br>

## 1. 최적화란

### 🕹️ 최적화(Optimization)

- 웹 서비스의 성능을 개선하는 모든 행위를 일컫는다.
- 아주 단순한 것부터 아주 어려운 방법까지 매우 다양하다.

<br>

#### 1️⃣ 일반적인 웹 서비스 최적화 방법

- 서버의 응답 속도 개선
- 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
- 불필요한 네트워크 요청 줄이기
- 기타 등등..

<br>

#### 2️⃣ React App 내부의 최적화 방법

- 컴포넌트 내부의 불 필요한 연산 방지
- 컴포넌트 내부의 불 필요한 함수 재생성 방지
- 컴포넌트의 불필요한 리렌더링 방지

<br>
<br>

## 2. `useMemo`와 연산 최적화

### 📍 `useMemo`

- 「메모이제이션」 기법을 기반으로 불필요한 연산을 최적화 하는 리액트 훅
- 자매품 : `useCallback`
- 사용 예시
  ```jsx
  useMemo(() => {}, []);
  ```
  - 컴포넌트를 인수로 받아와서, 해당 컴포넌트에 최적화 기능을 추가하여 반환

<br>

#### 📌 메모이제이션(Memoization)이란?

> 기억해두기, 메모해두기 라는 뜻

- 동일한 계산을 반복할 때 이전 계산 결과를 저장하여 불필요한 중복 연산을 방지하는 기법이다.
- 특히, 재귀 호출이 많은 알고리즘(예. 피보나치 수열, 동적 계획법)에서 성능을 최적화하는 데 자주 사용된다.

<br>

##### ✅ 주요 개념

- 처음 계산한 결과를 저장 (메모리에 기록)
- 다시 같은 계산이 필요하면 저장된 결과를 반환 (연산 생략)
- 프로그램 성능 향상 (연산 횟수 줄어듦 → 속도 증가)

<br>
<br>

## 3. `React.memo`와 컴포넌트 렌더링 최적화

### 📍 `React.memo`

- 컴포넌트를 인수로 받아, 최적화된 컴포넌트로 만들어 반환
- 컴포넌트가 받는 프롭스가 바뀌었을 때만 리렌더링(최적화)
- `memo` 메서드는 얕은 비교를 통해 값을 비교한다.
  - 객체 타입의 값을 `props`로 받고 있는 컴포넌트는 `memo` 메서드만으로 최적화 하기 어렵다.
  - 두 번째 인수로 콜백 함수를 전달하여 `prevProps`, `nextProps`의 비교를 통해 최적화할 수 있다.
- 예시
  ```jsx
  const MemoizedComponent = memo(Component);
  ```
  - `props`를 기준으로 메모이제이션 된다.

<br>

#### ⚠️ 동작 방식

- `React.memo`는 기본적으로 **얕은 비교(shallow comparison)** 를 사용한다.
  - `props`가 변경되지 않으면 리렌더링을 방지한다.
- 단순히 렌더링을 방지하기 때문에 **렌더링 비용이 높은 컴포넌트에만 유용** 하다.
  - 지나치게 남용할 경우, 불필요한 최적화로 인해 성능이 나빠질 수 있다.
- 클래스 컴포넌트에는 적용할 수 없고, **함수형 컴포넌트에서만 사용 가능** 하다.

<br>

#### ✨ 고차 컴포넌트(Higher-Order Component, HOC)

- 컴포넌트를 인수로 받아 새로운 컴포넌트를 반환하는 함수이다.
- 즉, 컴포넌트 로직을 재사용할 때 유용한 패턴이다.

<br>
<br>

## 4. `useCallback`과 함수 재생성 방지

### 📍 `useCallback`

- 함수를 메모이제이션 해준다.
- 사용 예시
  ```jsx
  const onCreate = useCallback(() => {}, []);
  ```
  - 첫 번째 인수 : 최적화하고 싶은 함수
  - 두 번째 인수 : 의존성 배열

<br>

### 📍 최적화는 언제 하는 게 좋을까?

> 기능 구현 ➡️ 최적화

1. 기능
2. 최적화

- 리액트 앱을 최적화할 때, 하나의 프로젝트를 거의 완성한 상태에서 하게 된다.
- 항상 기능을 구현하는 것이 우선시 되어야 하고, 기능이 완성된 이후 최적화를 하는 것이 일반적인 방법이다.
- **🔍최적화 알아보기** : [When to use useMemo, useCallback](https://goongoguma.github.io/2021/04/26/When-to-useMemo-and-useCallback/)
