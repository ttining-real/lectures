# 🍰 한입 크기로 잘라 먹는 리액트

## 섹션 10. 최적화

<br>

### 🌱 목차

- [x] 최적화란
- [x] `useMemo`와 연산 최적화
- [x] `React.memo`와 컴포넌트 렌더링 최적화
- [ ] `useCallback`과 함수 재생성 방지

<br>
<br>

## 1. 최적화란

### 🕹️ 최적화(Optimization)

- 웹 서비스의 성능을 개선하는 모든 행위를 일컫는다.
- 아주 단순한 것부터 아주 어려운 방법까지 매우 다양하다.

<br>

#### 1️⃣ 일반적인 웹 서비스 최적화 방법

- 서버의 응답 속도 개선
- 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
- 불필요한 네트워크 요청 줄이기
- 기타 등등..

<br>

#### 2️⃣ React App 내부의 최적화 방법

- 컴포넌트 내부의 불 필요한 연산 방지
- 컴포넌트 내부의 불 필요한 함수 재생성 방지
- 컴포넌트의 불필요한 리렌더링 방지

<br>
<br>

## 2. `useMemo`와 연산 최적화

### 📍 `useMemo`

- 「메모이제이션」 기법을 기반으로 불필요한 연산을 최적화 하는 리액트 훅
- 자매품 : `useCallback`

<br>

#### 📌 메모이제이션(Memoization)이란?

> 기억해두기, 메모해두기 라는 뜻

- 동일한 계산을 반복할 때 이전 계산 결과를 저장하여 불필요한 중복 연산을 방지하는 기법이다.
- 특히, 재귀 호출이 많은 알고리즘(예. 피보나치 수열, 동적 계획법)에서 성능을 최적화하는 데 자주 사용된다.

<br>

##### ✅ 주요 개념

- 처음 계산한 결과를 저장 (메모리에 기록)
- 다시 같은 계산이 필요하면 저장된 결과를 반환 (연산 생략)
- 프로그램 성능 향상 (연산 횟수 줄어듦 → 속도 증가)

<br>
<br>

## 3. `React.memo`와 컴포넌트 렌더링 최적화

### 📍 `React.memo`

- 컴포넌트를 인수로 받아, 최적화된 컴포넌트로 만들어 반환
- 예시
  ```jsx
  const MemoizedComponent = memo(Component);
  ```
  - `props`를 기준으로 메모이제이션 된다.

<br>

#### ⚠️ 동작 방식

- `React.memo`는 기본적으로 **얕은 비교(shallow comparison)** 를 사용한다.
  - `props`가 변경되지 않으면 리렌더링을 방지한다.
- 단순히 렌더링을 방지하기 때문에 **렌더링 비용이 높은 컴포넌트에만 유용** 하다.
  - 지나치게 남용할 경우, 불필요한 최적화로 인해 성능이 나빠질 수 있다.
- 클래스 컴포넌트에는 적용할 수 없고, **함수형 컴포넌트에서만 사용 가능** 하다.

<br>

#### ✨ 고차 컴포넌트(Higher-Order Component, HOC)

- 컴포넌트를 인수로 받아 새로운 컴포넌트를 반환하는 함수이다.
- 즉, 컴포넌트 로직을 재사용할 때 유용한 패턴이다.

<br>
<br>

## 4. `useCallback`과 함수 재생성 방지
