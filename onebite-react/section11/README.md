# 🍰 한입 크기로 잘라 먹는 리액트

```
2024. 09. 01(일)
```

<br>

### 섹션 11. Context

- [x] Context란
- [x] Context 사용하기
- [x] Context 분리하기

<br>

**`Context`란,**

- `Props`를 대체하여 컴포넌트 간의 데이터를 전달하는 또 하나의 방법 (편리해요!)
- 기존의 `Props`가 가지고 있던 단점을 해결할 수 있다.

<br>

**🤔 `Props`의 단점?**

- 부모 ➡️ 자식으로만 데이터를 전달할 수 있다.
- 조상 ➡️ 자식 컴포넌트로 데이터를 전달하기 위해서는 부모 컴포넌트가 중간 다리 역할을 해줘야 한다.
- 계층 구조가 복잡해질수록 번거로워진다. **😵‍💫 (Props Drilling) 😵‍💫**

> ✨ `React.Context`를 사용하면 프롭스 드릴링 해결 가능! ✨
>
> - 컨텍스트는 데이터를 보관하는 일종의 데이터 보관소의 역할을 하는 '객체'이다.
> - 컨텍스트를 여러 개 만드는 것도 가능하다.
>   - A 페이지에서는 A `Context`만 받도록 하고
>   - B 페이지에서는 B `Context`만 받도록 할 수 있다.

<br>

**`createContext()`**

- 일반적으로, 컴포넌트 외부에 선언한다. (특수한 경우 제외)
  - 컨텍스트의 역할 : 하위 컴포넌트에 데이터를 공급해주기 위함
  - 컴포넌트 리렌더링 시, 새로운 컨텍스트를 생성할 필요 X
- `Provider` : 이것도 컴포넌트이다..!
  - 컨텍스트가 공급할 데이터를 설정
  - 해당 컨텍스트의 데이터를 공급받을 컴포넌트를 설정
- 만약 `Provider`에 `value={Props}`로 전달한 것들이 계속 리렌더링 된다면 어떻게 해결할 수 있을까?
  - `memo`를 적용했더라도, `useContext`로부터 불러온 값이 변경되면 `props`가 변경된 것과 동일하게 리렌더링 된다.
  - 이 경우, 변경될 수 있는 값과 변경되지 않는 값으로 나눠서 컨텍스트를 관리하면 된다. (ex. `StateContext`, `DispatchContext`)
